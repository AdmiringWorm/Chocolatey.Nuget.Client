NuGet.DependencyResolver.GraphNode<TItem>.ParentNodes.get -> System.Collections.Generic.IList<NuGet.DependencyResolver.GraphNode<TItem>>
NuGet.DependencyResolver.IDependencyProvider.GetLibrary(NuGet.LibraryModel.LibraryRange libraryRange, Chocolatey.NuGet.Frameworks.NuGetFramework targetFramework) -> NuGet.LibraryModel.Library
NuGet.DependencyResolver.IRemoteDependencyProvider.FindLibraryAsync(NuGet.LibraryModel.LibraryRange libraryRange, Chocolatey.NuGet.Frameworks.NuGetFramework targetFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.LibraryModel.LibraryIdentity>
NuGet.DependencyResolver.IRemoteDependencyProvider.GetDependenciesAsync(NuGet.LibraryModel.LibraryIdentity libraryIdentity, Chocolatey.NuGet.Frameworks.NuGetFramework targetFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.LibraryModel.LibraryDependencyInfo>
NuGet.DependencyResolver.LibraryRangeCacheKey.Framework.get -> Chocolatey.NuGet.Frameworks.NuGetFramework
NuGet.DependencyResolver.LibraryRangeCacheKey.LibraryRangeCacheKey(NuGet.LibraryModel.LibraryRange range, Chocolatey.NuGet.Frameworks.NuGetFramework framework) -> void
NuGet.DependencyResolver.LocalDependencyProvider.FindLibraryAsync(NuGet.LibraryModel.LibraryRange libraryRange, Chocolatey.NuGet.Frameworks.NuGetFramework targetFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.LibraryModel.LibraryIdentity>
NuGet.DependencyResolver.LocalDependencyProvider.GetDependenciesAsync(NuGet.LibraryModel.LibraryIdentity libraryIdentity, Chocolatey.NuGet.Frameworks.NuGetFramework targetFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.LibraryModel.LibraryDependencyInfo>
NuGet.DependencyResolver.LockFileCacheKey.LockFileCacheKey(Chocolatey.NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier) -> void
NuGet.DependencyResolver.LockFileCacheKey.TargetFramework.get -> Chocolatey.NuGet.Frameworks.NuGetFramework
NuGet.DependencyResolver.RemoteDependencyWalker.WalkAsync(NuGet.LibraryModel.LibraryRange library, Chocolatey.NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier, NuGet.RuntimeModel.RuntimeGraph runtimeGraph, bool recursive) -> System.Threading.Tasks.Task<NuGet.DependencyResolver.GraphNode<NuGet.DependencyResolver.RemoteResolveResult>>
static NuGet.DependencyResolver.ResolverUtility.FindLibraryByVersionAsync(NuGet.LibraryModel.LibraryRange libraryRange, Chocolatey.NuGet.Frameworks.NuGetFramework framework, System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.IRemoteDependencyProvider> providers, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.DependencyResolver.RemoteMatch>
static NuGet.DependencyResolver.ResolverUtility.FindLibraryCachedAsync(System.Collections.Concurrent.ConcurrentDictionary<NuGet.DependencyResolver.LibraryRangeCacheKey, System.Threading.Tasks.Task<NuGet.DependencyResolver.GraphItem<NuGet.DependencyResolver.RemoteResolveResult>>> cache, NuGet.LibraryModel.LibraryRange libraryRange, Chocolatey.NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier, NuGet.DependencyResolver.RemoteWalkContext context, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.DependencyResolver.GraphItem<NuGet.DependencyResolver.RemoteResolveResult>>
static NuGet.DependencyResolver.ResolverUtility.FindLibraryEntryAsync(NuGet.LibraryModel.LibraryRange libraryRange, Chocolatey.NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier, NuGet.DependencyResolver.RemoteWalkContext context, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.DependencyResolver.GraphItem<NuGet.DependencyResolver.RemoteResolveResult>>
static NuGet.DependencyResolver.ResolverUtility.FindLibraryMatchAsync(NuGet.LibraryModel.LibraryRange libraryRange, Chocolatey.NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier, System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.IRemoteDependencyProvider> remoteProviders, System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.IRemoteDependencyProvider> localProviders, System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.IDependencyProvider> projectProviders, System.Collections.Generic.IDictionary<NuGet.DependencyResolver.LockFileCacheKey, System.Collections.Generic.IList<NuGet.LibraryModel.LibraryIdentity>> lockFileLibraries, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.DependencyResolver.RemoteMatch>
static NuGet.DependencyResolver.ResolverUtility.FindProjectMatchAsync(NuGet.LibraryModel.LibraryRange libraryRange, Chocolatey.NuGet.Frameworks.NuGetFramework framework, System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.IDependencyProvider> projectProviders, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.DependencyResolver.RemoteMatch>
*REMOVED* NuGet.DependencyResolver.IDependencyProvider.GetLibrary(NuGet.LibraryModel.LibraryRange libraryRange, NuGet.Frameworks.NuGetFramework targetFramework) -> NuGet.LibraryModel.Library
*REMOVED* NuGet.DependencyResolver.IRemoteDependencyProvider.FindLibraryAsync(NuGet.LibraryModel.LibraryRange libraryRange, NuGet.Frameworks.NuGetFramework targetFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.LibraryModel.LibraryIdentity>
*REMOVED* NuGet.DependencyResolver.IRemoteDependencyProvider.GetDependenciesAsync(NuGet.LibraryModel.LibraryIdentity libraryIdentity, NuGet.Frameworks.NuGetFramework targetFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.LibraryModel.LibraryDependencyInfo>
*REMOVED* NuGet.DependencyResolver.LibraryRangeCacheKey.Framework.get -> NuGet.Frameworks.NuGetFramework
*REMOVED* NuGet.DependencyResolver.LibraryRangeCacheKey.LibraryRangeCacheKey(NuGet.LibraryModel.LibraryRange range, NuGet.Frameworks.NuGetFramework framework) -> void
*REMOVED* NuGet.DependencyResolver.LocalDependencyProvider.FindLibraryAsync(NuGet.LibraryModel.LibraryRange libraryRange, NuGet.Frameworks.NuGetFramework targetFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.LibraryModel.LibraryIdentity>
*REMOVED* NuGet.DependencyResolver.LocalDependencyProvider.GetDependenciesAsync(NuGet.LibraryModel.LibraryIdentity libraryIdentity, NuGet.Frameworks.NuGetFramework targetFramework, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.LibraryModel.LibraryDependencyInfo>
*REMOVED* NuGet.DependencyResolver.LockFileCacheKey.LockFileCacheKey(NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier) -> void
*REMOVED* NuGet.DependencyResolver.LockFileCacheKey.TargetFramework.get -> NuGet.Frameworks.NuGetFramework
*REMOVED* NuGet.DependencyResolver.RemoteDependencyWalker.WalkAsync(NuGet.LibraryModel.LibraryRange library, NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier, NuGet.RuntimeModel.RuntimeGraph runtimeGraph, bool recursive) -> System.Threading.Tasks.Task<NuGet.DependencyResolver.GraphNode<NuGet.DependencyResolver.RemoteResolveResult>>
*REMOVED* static NuGet.DependencyResolver.ResolverUtility.FindLibraryByVersionAsync(NuGet.LibraryModel.LibraryRange libraryRange, NuGet.Frameworks.NuGetFramework framework, System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.IRemoteDependencyProvider> providers, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken token) -> System.Threading.Tasks.Task<NuGet.DependencyResolver.RemoteMatch>
*REMOVED* static NuGet.DependencyResolver.ResolverUtility.FindLibraryCachedAsync(System.Collections.Concurrent.ConcurrentDictionary<NuGet.DependencyResolver.LibraryRangeCacheKey, System.Threading.Tasks.Task<NuGet.DependencyResolver.GraphItem<NuGet.DependencyResolver.RemoteResolveResult>>> cache, NuGet.LibraryModel.LibraryRange libraryRange, NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier, NuGet.DependencyResolver.RemoteWalkContext context, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.DependencyResolver.GraphItem<NuGet.DependencyResolver.RemoteResolveResult>>
*REMOVED* static NuGet.DependencyResolver.ResolverUtility.FindLibraryEntryAsync(NuGet.LibraryModel.LibraryRange libraryRange, NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier, NuGet.DependencyResolver.RemoteWalkContext context, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.DependencyResolver.GraphItem<NuGet.DependencyResolver.RemoteResolveResult>>
*REMOVED* static NuGet.DependencyResolver.ResolverUtility.FindLibraryMatchAsync(NuGet.LibraryModel.LibraryRange libraryRange, NuGet.Frameworks.NuGetFramework framework, string runtimeIdentifier, System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.IRemoteDependencyProvider> remoteProviders, System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.IRemoteDependencyProvider> localProviders, System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.IDependencyProvider> projectProviders, System.Collections.Generic.IDictionary<NuGet.DependencyResolver.LockFileCacheKey, System.Collections.Generic.IList<NuGet.LibraryModel.LibraryIdentity>> lockFileLibraries, NuGet.Protocol.Core.Types.SourceCacheContext cacheContext, NuGet.Common.ILogger logger, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.DependencyResolver.RemoteMatch>
*REMOVED* static NuGet.DependencyResolver.ResolverUtility.FindProjectMatchAsync(NuGet.LibraryModel.LibraryRange libraryRange, NuGet.Frameworks.NuGetFramework framework, System.Collections.Generic.IEnumerable<NuGet.DependencyResolver.IDependencyProvider> projectProviders, System.Threading.CancellationToken cancellationToken) -> System.Threading.Tasks.Task<NuGet.DependencyResolver.RemoteMatch>